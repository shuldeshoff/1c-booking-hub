// ====================================================================
// Модуль управления очередями (Queue Manager)
// ====================================================================
// Назначение: Асинхронная обработка заказов с приоритетами и retry
// Автор: Шульдешов Юрий Леонидович (shuldeshoff@mail.ru)
// Версия: 2.0
// Паттерны: Producer-Consumer, Priority Queue, Command Pattern
// ====================================================================

#Область ПрограммныйИнтерфейс

// Добавить задачу в очередь обработки
//
// Параметры:
//   ДанныеЗадачи - Структура - Данные для обработки
//   Приоритет - Число - Приоритет задачи (1-высокий, 2-средний, 3-низкий)
//   ТипЗадачи - Строка - Тип задачи (LoadOrders, ProcessOrder, SendWebhook)
//
// Возвращаемое значение:
//   УникальныйИдентификатор - Идентификатор задачи в очереди
//
Функция ДобавитьВОчередь(ДанныеЗадачи, Приоритет = 2, ТипЗадачи = "ProcessOrder") Экспорт
	
	УИДЗадачи = Новый УникальныйИдентификатор;
	
	// Создаем запись в регистре сведений "ОчередьЗадач"
	МенеджерЗаписи = РегистрыСведений.ОчередьЗадач.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.УИДЗадачи = УИДЗадачи;
	МенеджерЗаписи.ДатаСоздания = ТекущаяДатаСеанса();
	МенеджерЗаписи.Приоритет = Приоритет;
	МенеджерЗаpisи.ТипЗадачи = ТипЗадачи;
	МенеджерЗаписи.Статус = Перечисления.СтатусыЗадач.Ожидает;
	МенеджерЗаписи.ДанныеЗадачи = Новый ХранилищеЗначения(ДанныеЗадачи);
	МенеджерЗаписи.КоличествоПопыток = 0;
	МенеджерЗаписи.МаксимальноПопыток = 3;
	МенеджерЗаписи.Записать();
	
	ЗаписатьЛог("Информация", СтрШаблон(
		"Задача %1 (тип: %2, приоритет: %3) добавлена в очередь",
		УИДЗадачи, ТипЗадачи, Приоритет));
	
	Возврат УИДЗадачи;
	
КонецФункции

// Обработать задачи из очереди
//
// Параметры:
//   МаксимальноЗадач - Число - Максимальное количество задач для обработки
//   ТолькоТип - Строка - Обрабатывать только задачи указанного типа
//
Процедура ОбработатьОчередь(МаксимальноЗадач = 10, ТолькоТип = "") Экспорт
	
	// Получаем задачи с наивысшим приоритетом
	МассивЗадач = ПолучитьЗадачиИзОчереди(МаксимальноЗадач, ТолькоТип);
	
	Для Каждого Задача Из МассивЗадач Цикл
		
		Попытка
			// Помечаем задачу как выполняющуюся
			УстановитьСтатусЗадачи(Задача.УИДЗадачи, Перечисления.СтатусыЗадач.ВРаботе);
			
			// Выполняем задачу
			РезультатВыполнения = ВыполнитьЗадачу(Задача);
			
			Если РезультатВыполнения.Успех Тогда
				// Задача выполнена успешно
				УстановитьСтатусЗадачи(Задача.УИДЗадачи, Перечисления.СтатусыЗадач.Выполнена);
				
				ЗаписатьЛог("Информация", СтрШаблон(
					"Задача %1 выполнена успешно за %2 сек",
					Задача.УИДЗадачи, 
					РезультатВыполнения.ВремяВыполнения));
			Иначе
				// Задача завершилась с ошибкой - планируем retry
				ОбработатьОшибкуЗадачи(Задача, РезультатВыполнения.ТекстОшибки);
			КонецЕсли;
			
		Исключение
			ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			ОбработатьОшибкуЗадачи(Задача, ТекстОшибки);
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

// Получить статистику очереди
//
// Возвращаемое значение:
//   Структура - Статистика по очереди
//
Функция ПолучитьСтатистикуОчереди() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ОчередьЗадач.Статус КАК Статус,
	|	ОчередьЗадач.ТипЗадачи КАК ТипЗадачи,
	|	КОЛИЧЕСТВО(ОчередьЗадач.УИДЗадачи) КАК Количество,
	|	СРЕДНЕЕ(РАЗНОСТЬДАТ(ОчередьЗадач.ДатаСоздания, ОчередьЗадач.ДатаОбновления, СЕКУНДА)) КАК СреднееВремяВыполнения
	|ИЗ
	|	РегистрСведений.ОчередьЗадач КАК ОчередьЗадач
	|СГРУППИРОВАТЬ ПО
	|	ОчередьЗадач.Статус,
	|	ОчередьЗадач.ТипЗадачи";
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Статистика = Новый Структура;
	Статистика.Вставить("ВОжидании", 0);
	Статистика.Вставить("ВРаботе", 0);
	Статистика.Вставить("Выполнено", 0);
	Статистика.Вставить("Ошибка", 0);
	Статистика.Вставить("ПоТипам", Новый Соответствие);
	
	Пока Выборка.Следующий() Цикл
		Если Выборка.Статус = Перечисления.СтатусыЗадач.Ожидает Тогда
			Статистика.ВОжидании = Статистика.ВОжидании + Выборка.Количество;
		ИначеЕсли Выборка.Статус = Перечисления.СтатусыЗадач.ВРаботе Тогда
			Статистика.ВРаботе = Статистика.ВРаботе + Выборка.Количество;
		ИначеЕсли Выборка.Статус = Перечисления.СтатусыЗадач.Выполнена Тогда
			Статистика.Выполнено = Статистика.Выполнено + Выборка.Количество;
		ИначеЕсли Выборка.Статус = Перечисления.СтатусыЗадач.Ошибка Тогда
			Статистика.Ошибка = Статистика.Ошибка + Выборка.Количество;
		КонецЕсли;
		
		Статистика.ПоТипам.Вставить(Выборка.ТипЗадачи, Выборка.Количество);
	КонецЦикла;
	
	Возврат Статистика;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Получить задачи из очереди для обработки
//
Функция ПолучитьЗадачиИзОчереди(МаксимальноЗадач, ТолькоТип)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ &МаксимальноЗадач
	|	ОчередьЗадач.УИДЗадачи КАК УИДЗадачи,
	|	ОчередьЗадач.ТипЗадачи КАК ТипЗадачи,
	|	ОчередьЗадач.ДанныеЗадачи КАК ДанныеЗадачи,
	|	ОчередьЗадач.Приоритет КАК Приоритет,
	|	ОчередьЗадач.КоличествоПопыток КАК КоличествоПопыток,
	|	ОчередьЗадач.МаксимальноПопыток КАК МаксимальноПопыток
	|ИЗ
	|	РегистрСведений.ОчередьЗадач КАК ОчередьЗадач
	|ГДЕ
	|	ОчередьЗадач.Статус = &СтатусОжидает
	|	&УсловиеТипа
	|	И (ОчередьЗадач.СледующаяПопытка ЕСТЬ NULL
	|		ИЛИ ОчередьЗадач.СледующаяПопытка <= &ТекущаяДата)
	|УПОРЯДОЧИТЬ ПО
	|	ОчередьЗадач.Приоритет,
	|	ОчередьЗадач.ДатаСоздания";
	
	Запрос.УстановитьПараметр("МаксимальноЗадач", МаксимальноЗадач);
	Запрос.УстановитьПараметр("СтатусОжидает", Перечисления.СтатусыЗадач.Ожидает);
	Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДатаСеанса());
	
	Если ПустаяСтрока(ТолькоТип) Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеТипа", "");
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеТипа", "И ОчередьЗадач.ТипЗадачи = &ТипЗадачи");
		Запрос.УстановитьПараметр("ТипЗадачи", ТолькоТип);
	КонецЕсли;
	
	Результат = Запрос.Выполнить();
	
	МассивЗадач = Новый Массив;
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Задача = Новый Структура;
		Задача.Вставить("УИДЗадачи", Выборка.УИДЗадачи);
		Задача.Вставить("ТипЗадачи", Выборка.ТипЗадачи);
		Задача.Вставить("ДанныеЗадачи", Выборка.ДанныеЗадачи.Получить());
		Задача.Вставить("Приоритет", Выборка.Приоритет);
		Задача.Вставить("КоличествоПопыток", Выборка.КоличествоПопыток);
		Задача.Вставить("МаксимальноПопыток", Выборка.МаксимальноПопыток);
		
		МассивЗадач.Добавить(Задача);
		
	КонецЦикла;
	
	Возврат МассивЗадач;
	
КонецФункции

// Выполнить задачу (Command Pattern)
//
Функция ВыполнитьЗадачу(Задача)
	
	ВремяНачала = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Результат = Новый Структура;
	Результат.Вставить("Успех", Ложь);
	Результат.Вставить("ТекстОшибки", "");
	Результат.Вставить("ВремяВыполнения", 0);
	
	Попытка
		
		// Диспетчеризация по типу задачи
		Если Задача.ТипЗадачи = "LoadOrders" Тогда
			МодульИнтеграции.ЗагрузитьЗаказыИзAPI(Задача.ДанныеЗадачи);
			
		ИначеЕсли Задача.ТипЗадачи = "ProcessOrder" Тогда
			МодульИнтеграции.ОбработатьОдинЗаказ(Задача.ДанныеЗадачи);
			
		ИначеЕсли Задача.ТипЗадачи = "SendWebhook" Тогда
			МодульWebhook.ОтправитьWebhook(Задача.ДанныеЗадачи);
			
		ИначеЕсли Задача.ТипЗадачи = "UpdateCache" Тогда
			МодульКеширования.ОбновитьКеш(Задача.ДанныеЗадачи);
			
		Иначе
			ВызватьИсключение "Неизвестный тип задачи: " + Задача.ТипЗадачи;
		КонецЕсли;
		
		Результат.Успех = Истина;
		
	Исключение
		Результат.ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	ВремяОкончания = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Результат.ВремяВыполнения = (ВремяОкончания - ВремяНачала) / 1000; // в секундах
	
	Возврат Результат;
	
КонецФункции

// Установить статус задачи
//
Процедура УстановитьСтатусЗадачи(УИДЗадачи, Статус, ТекстОшибки = "")
	
	МенеджерЗаписи = РегистрыСведений.ОчередьЗадач.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.УИДЗадачи = УИДЗадачи;
	МенеджерЗаписи.Прочитать();
	
	Если МенеджерЗаписи.Выбран() Тогда
		МенеджерЗаписи.Статус = Статус;
		МенеджерЗаписи.ДатаОбновления = ТекущаяДатаСеанса();
		
		Если НЕ ПустаяСтрока(ТекстОшибки) Тогда
			МенеджерЗаписи.ТекстОшибки = ТекстОшибки;
		КонецЕсли;
		
		МенеджерЗаписи.Записать();
	КонецЕсли;
	
КонецПроцедуры

// Обработать ошибку задачи с retry логикой (Exponential Backoff)
//
Процедура ОбработатьОшибкуЗадачи(Задача, ТекстОшибки)
	
	МенеджерЗаписи = РегистрыСведений.ОчередьЗадач.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.УИДЗадачи = Задача.УИДЗадачи;
	МенеджерЗаписи.Прочитать();
	
	Если МенеджерЗаписи.Выбран() Тогда
		
		НоваяПопытка = МенеджерЗаписи.КоличествоПопыток + 1;
		
		Если НоваяПопытка >= МенеджерЗаписи.МаксимальноПопыток Тогда
			// Исчерпаны все попытки - помечаем как ошибку
			МенеджерЗаписи.Статус = Перечисления.СтатусыЗадач.Ошибка;
			МенеджерЗаписи.ТекстОшибки = ТекстОшибки;
			
			ЗаписатьЛог("Ошибка", СтрШаблон(
				"Задача %1 отменена после %2 попыток: %3",
				Задача.УИДЗадачи, НоваяПопытка, ТекстОшибки));
			
			// Отправляем уведомление администратору
			ОтправитьУведомлениеОбОшибке(Задача, ТекстОшибки);
			
		Иначе
			// Планируем повторную попытку с экспоненциальной задержкой
			// Задержка = 2^попытка минут (1 мин, 2 мин, 4 мин, 8 мин...)
			ЗадержкаВМинутах = Pow(2, НоваяПопытка);
			СледующаяПопытка = ТекущаяДатаСеанса() + ЗадержкаВМинутах * 60;
			
			МенеджерЗаписи.Статус = Перечисления.СтатусыЗадач.Ожидает;
			МенеджерЗаписи.КоличествоПопыток = НоваяПопытка;
			МенеджерЗаписи.СледующаяПопытка = СледующаяПопытка;
			МенеджерЗаписи.ТекстОшибки = ТекстОшибки;
			
			ЗаписатьЛог("Предупреждение", СтрШаблон(
				"Задача %1 будет повторена через %2 мин (попытка %3/%4)",
				Задача.УИДЗадачи, ЗадержкаВМинутах, НоваяПопытка, МенеджерЗаписи.МаксимальноПопыток));
		КонецЕсли;
		
		МенеджерЗаписи.ДатаОбновления = ТекущаяДатаСеанса();
		МенеджерЗаписи.Записать();
		
	КонецЕсли;
	
КонецПроцедуры

// Отправить уведомление об ошибке администратору
//
Процедура ОтправитьУведомлениеОбОшибке(Задача, ТекстОшибки)
	
	// Можно отправить Email, Telegram, создать задачу в трекере и т.д.
	// Для примера - записываем в журнал регистрации
	
	ЗаписьЖурналаРегистрации(
		"ОчередьЗадач.КритическаяОшибка",
		УровеньЖурналаРегистрации.Ошибка,
		,
		Задача.УИДЗадачи,
		СтрШаблон("Задача %1 (тип: %2) отменена: %3", 
			Задача.УИДЗадачи, Задача.ТипЗадачи, ТекстОшибки));
	
КонецПроцедуры

#КонецОбласти

// ====================================================================
// АРХИТЕКТУРНЫЕ РЕШЕНИЯ:
// 
// 1. Producer-Consumer Pattern - разделение создания и обработки задач
// 2. Priority Queue - задачи обрабатываются по приоритету
// 3. Command Pattern - единообразное выполнение разных типов задач
// 4. Retry Pattern с Exponential Backoff - надежность при сбоях
// 5. Circuit Breaker (через счетчик попыток) - защита от повторяющихся ошибок
// 6. Observability - полное логирование и метрики
// 
// ПРЕИМУЩЕСТВА:
// - Асинхронная обработка не блокирует пользователя
// - Надежность при сбоях сети или внешних сервисов
// - Масштабируемость - можно запускать несколько обработчиков
// - Приоритизация критичных задач
// - Monitoring и debugging через статистику
// ====================================================================

